#lang racket/base
(provide add sub shiftr shiftl read put cur)

;; former current latter
;; (vector/c list? byte? list?)
(define main-vector (vector null 0 null))

(define-syntax-rule (make-mutator-and-accessor vec ind)
  (case-lambda
    (() (vector-ref vec ind))
    ((v) (vector-set! vec ind v))))

(define cur (make-mutator-and-accessor main-vector 1))
(define former (make-mutator-and-accessor main-vector 0))
(define latter (make-mutator-and-accessor main-vector 2))

;; n: exact-positive-integer?
(define (add n)
  (cur (bitwise-and (+ n (cur)) 255)))
(define (sub n)
  (cur (bitwise-and (- (cur) n) 255)))
(define (shiftr n)
  (let loop ((f (former))
             (c (cur))
             (l (latter))
             (i n))
    (if (zero? i)
        (begin (former f)
               (cur c)
               (latter l))
        (if (null? f)
            (loop null 0 (cons c l) (sub1 i))
            (loop (cdr f) (car f) (cons c l) (sub1 i))))))
(define (shiftl n)
  (let loop ((f (former))
             (c (cur))
             (l (latter))
             (i n))
    (if (zero? i)
        (begin (former f)
               (cur c)
               (latter l))
        (if (null? l)
            (loop (cons c f) 0 null (sub1 i))
            (loop (cons c f) (car l) (cdr l) (sub1 i))))))
(define (read n)
  (cur
   (for/last ((_ (in-range n)))
     (read-byte))))
(define (put n)
  (define bt (cur))
  (for ((_ (in-range n)))
    (write-byte bt)))
